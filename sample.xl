import core;
import my;

class Foo
{
    fun Foo(a : core.int, b)
    {
        my.print("int ctor");
        my.print(a);
        my.print(b);
        self.a = a;
    }

    fun Foo(a : core.string, b)
    {
        my.print("string ctor");
        my.print(a);
        my.print(b);
        self.a = a;
    }

    fun polymorphic(a)
        my.print("default version");

    fun polymorphic(a : core.int)
    {
        my.print("int version");
        my.print(a);
    }

    fun polymorphic(a : core.string)
    {
        my.print("string version");
        my.print(a);
    }

    fun polymorphic(a : Foo)
    {
        my.print("Foo version");
    }

    fun __serialize__()
        return "";
};

fun foo()
    return;

a = core.list(10, "a");
a.set(5, "b");

i = 0;
while (i < a.size())
{
    my.print(a.get(i));
    i = i+1;
}

// a = Foo(1, 2);

// //n = core.int(5);

// my.print(1.__classname__);
// my.print(Foo.__classname__);
// my.print(my.print.__classname__);
// my.print(core.Nil().__classname__);

// // a = Foo(1, 2);
// // b = Foo("4", 8);
// // a.polymorphic(8);
// // a.polymorphic("8");
// // a.polymorphic(a);

// // default == and < operators w/ serialize + classid
// // store constants by classid (not by classname)
// // problem w/ ctor wrapper (takes precedency over overloaded ctors)
// //   -> setup a single variadic __call__(...) that chooses polymorphically the ctor itself
